{\rtf1\ansi\ansicpg1252\cocoartf2576
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fswiss\fcharset0 ArialMT;\f2\fswiss\fcharset0 Arial-BoldMT;
\f3\fnil\fcharset0 Verdana;\f4\fnil\fcharset0 Verdana-Bold;\f5\fmodern\fcharset0 CourierNewPSMT;
\f6\fnil\fcharset0 Monaco;\f7\fswiss\fcharset0 Helvetica-Bold;\f8\fmodern\fcharset0 CourierNewPS-BoldMT;
}
{\colortbl;\red255\green255\blue255;\red19\green0\blue155;\red0\green0\blue0;\red24\green25\blue27;
\red0\green0\blue0;\red255\green255\blue255;\red159\green159\blue159;\red241\green241\blue241;\red94\green224\blue89;
\red168\green72\blue4;\red247\green247\blue247;\red107\green0\blue109;\red10\green86\blue216;\red3\green53\blue197;
\red38\green38\blue38;\red1\green30\blue103;\red16\green121\blue2;\red192\green0\blue4;}
{\*\expandedcolortbl;;\cssrgb\c10196\c5098\c67059;\cssrgb\c0\c0\c0\c3137;\cssrgb\c12549\c12941\c14118;
\cssrgb\c0\c0\c0;\cssrgb\c100000\c100000\c100000;\cssrgb\c68627\c68627\c68627;\cssrgb\c95686\c95686\c95686;\cssrgb\c42353\c88627\c42353;
\cssrgb\c72157\c36078\c0;\cssrgb\c97647\c97647\c97647;\cssrgb\c50196\c0\c50196;\cssrgb\c0\c43529\c87843;\cssrgb\c0\c30588\c81569;
\cssrgb\c20000\c20000\c20000;\cssrgb\c0\c17647\c47843;\cssrgb\c0\c53333\c0;\cssrgb\c80784\c0\c0;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \
\pard\pardeftab720\partightenfactor0
{\field{\*\fldinst{HYPERLINK "https://www.google.com/search?q=stack+overflow+and+underflow+meaning&rlz=1C5CHFA_enIN910IN910&sxsrf=ALeKk00QFhMXwVotZuEGVF3DEeOrq3JhRQ:1613659218549&tbm=isch&source=iu&ictx=1&fir=gwHg2__stfoozM%252Cb0Jhy29wBe5lFM%252C_&vet=1&usg=AI4_-kS51JCGhj1TAYz-iet-0VaJeQCmeQ&sa=X&ved=2ahUKEwiL74mE1fPuAhU28HMBHexbB2IQ9QF6BAgWEAE#imgrc=gwHg2__stfoozM"}}{\fldrslt 
\f1\fs28 \cf2 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \
}}\pard\pardeftab720\sl440\partightenfactor0

\f2\b\fs40 \cf4 \expnd0\expndtw0\kerning0
ASSERTION\

\f1\b0\fs28 \
\pard\pardeftab720\partightenfactor0

\f3\fs26 \cf5 \cb6 An\'a0
\f4\b assertion
\f3\b0 \'a0is an expression that will be true unless there is a bug in the program. If the expression evaluates to\'a0
\f5 true
\f3 , the assertion statement does nothing. If the conditional expression evaluates to\'a0
\f5 false
\f3 , an error message is displayed and the program is terminated (via\'a0
\f5 std::abort
\f3 ). This error message typically contains the expression that failed as text, along with the name of the code file and the line number of the assertion. This makes it very easy to tell not only what the problem was, but where in the code the problem occurred. This can help with debugging efforts immensely.\
\
\pard\pardeftab720\sa260\partightenfactor0
\cf5 In C++, runtime assertions are implemented via the\'a0
\f4\b assert
\f3\b0 \'a0preprocessor macro, which lives in the <cassert> header.\
\
\pard\pardeftab720\sl300\partightenfactor0

\f6\fs24 \cf5 \cb1 \

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalt \clcbpat8 \clwWidth488\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrs\brdrw60\brdrcf9 \clpadl0 \clpadr100 \gaph\cellx4320
\clvertalt \clcbpat8 \clwWidth15963\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadl0 \clpadr0 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\sl300\qc\partightenfactor0
\cf7 \cb6 1\cb1 \
\cb6 2\cb1 \
\cb6 3\cb1 \
\cb6 4\cb1 \
\cb6 5\cb1 \
\cb6 6\cb1 \
\cb6 7\cb1 \
\cb6 8\cb1 \
\cb6 9\cb1 \
\cb6 10\cb1 \
\cb6 11\cb1 \
\cb6 12\cb1 \
\cb6 13\cb1 \
\cb6 14\cb1 \
\cb6 15\cb1 \
\cb6 16\cb1 \
\cb6 17\cb1 \
\cb6 18\cb1 \
\cb6 19\cb1 \
\cb6 20\cb1 \
\cb6 21\cb1 \
\cb6 22\cb1 \
\cb6 23\cb1 \cell 
\pard\intbl\itap1\pardeftab720\sl300\partightenfactor0
\cf10 \cb6 #include <cassert> // for assert()\cf5 \cb1 \
\pard\intbl\itap1\pardeftab720\sl300\partightenfactor0
\cf10 \cb11 #include <cmath> // for std::sqrt\cf5 \
\pard\intbl\itap1\pardeftab720\sl300\partightenfactor0
\cf10 \cb6 #include <iostream>\cf5 \cb1 \
\pard\intbl\itap1\pardeftab720\sl300\partightenfactor0
\cf5 \cb11 \'a0\
\pard\intbl\itap1\pardeftab720\sl300\partightenfactor0
\cf12 \cb6 double\cf13  \cf14 calculateTimeUntilObjectHitsGround\cf15 (\cf12 double\cf13  \cf16 initialHeight\cf15 ,\cf13  \cf12 double\cf13  \cf16 gravity\cf15 )\cf5 \cb1 \
\pard\intbl\itap1\pardeftab720\sl300\partightenfactor0
\cf15 \cb11 \{\cf5 \
\pard\intbl\itap1\pardeftab720\sl300\partightenfactor0
\cf13 \cb6 \'a0\'a0\cf12 assert\cf15 (\cf16 gravity\cf13  > \cf16 0.0\cf15 );\cf13  \cf17 // The object won't reach the ground unless there is positive gravity.\cf5 \cb1 \
\pard\intbl\itap1\pardeftab720\sl300\partightenfactor0
\cf13 \cb11  \cf5 \
\pard\intbl\itap1\pardeftab720\sl300\partightenfactor0
\cf13 \cb6 \'a0\'a0\cf12 if\cf13  \cf15 (\cf16 initialHeight\cf13  <= \cf16 0.0\cf15 )\cf5 \cb1 \
\pard\intbl\itap1\pardeftab720\sl300\partightenfactor0
\cf13 \cb11 \'a0\'a0\cf15 \{\cf5 \
\pard\intbl\itap1\pardeftab720\sl300\partightenfactor0
\cf13 \cb6 \'a0\'a0\'a0\'a0\cf17 // The object is already on the ground. Or buried.\cf5 \cb1 \
\pard\intbl\itap1\pardeftab720\sl300\partightenfactor0
\cf13 \cb11 \'a0\'a0\'a0\'a0\cf12 return\cf13  \cf16 0.0\cf15 ;\cf5 \
\pard\intbl\itap1\pardeftab720\sl300\partightenfactor0
\cf13 \cb6 \'a0\'a0\cf15 \}\cf5 \cb1 \
\pard\intbl\itap1\pardeftab720\sl300\partightenfactor0
\cf13 \cb11  \cf5 \
\pard\intbl\itap1\pardeftab720\sl300\partightenfactor0
\cf13 \cb6 \'a0\'a0\cf12 return\cf13  \cf16 std\cf13 ::\cf14 sqrt\cf15 ((\cf16 2.0\cf13  * \cf16 initialHeight\cf15 )\cf13  / \cf16 gravity\cf15 );\cf5 \cb1 \
\pard\intbl\itap1\pardeftab720\sl300\partightenfactor0
\cf15 \cb11 \}\cf5 \
\pard\intbl\itap1\pardeftab720\sl300\partightenfactor0
\cf5 \cb6 \'a0\cb1 \
\pard\intbl\itap1\pardeftab720\sl300\partightenfactor0
\cf12 \cb11 int\cf13  \cf14 main\cf15 ()\cf5 \
\pard\intbl\itap1\pardeftab720\sl300\partightenfactor0
\cf15 \cb6 \{\cf5 \cb1 \
\pard\intbl\itap1\pardeftab720\sl300\partightenfactor0
\cf13 \cb11 \'a0\'a0\cf16 std\cf13 ::\cf12 cout\cf13  << \cf18 "Took "\cf13  << \cf14 calculateTimeUntilObjectHitsGround\cf15 (\cf16 100.0\cf15 ,\cf13  -\cf16 9.8\cf15 )\cf13  << \cf18 " second(s)\\n"\cf15 ;\cf5 \
\pard\intbl\itap1\pardeftab720\sl300\partightenfactor0
\cf5 \cb6 \'a0\cb1 \
\pard\intbl\itap1\pardeftab720\sl300\partightenfactor0
\cf13 \cb11 \'a0\'a0\cf12 return\cf13  \cf16 0\cf15 ;\cf5 \
\pard\intbl\itap1\pardeftab720\sl300\partightenfactor0
\cf15 \cb6 \}\cf5 \cb1 \cell \lastrow\row
\pard\pardeftab720\sa260\partightenfactor0

\f3\fs26 \cf5 \cb6 \
When the program calls\'a0
\f5 calculateTimeUntilObjectHitsGround(100.0, -9.8)
\f3 ,\'a0
\f5 assert(gravity > 0.0)
\f3 \'a0will evaluate to\'a0
\f5 false
\f3 , which will trigger the assert. That will print a message similar to this:\
\pard\pardeftab720\sa360\partightenfactor0

\f7\b\fs36 \cf5 static_assert\
\pard\pardeftab720\sa260\partightenfactor0

\f3\b0\fs26 \cf5 C++11 added another type of assert called\'a0
\f5 static_assert
\f3 . A\'a0
\f4\b static_assert
\f3\b0 \'a0is an assertion that is checked at compile-time rather than at runtime, with a failing\'a0
\f5 static_assert
\f3 \'a0causing a compile error.\
A\'a0
\f5 static_assert
\f3 \'a0takes the following form:\
\pard\pardeftab720\partightenfactor0

\f8\b \cf5 static_assert(condition, diagnostic_message)
\f5\b0 \
\pard\pardeftab720\sa260\partightenfactor0

\f3 \cf5 If the condition is not true, the diagnostic message is printed. Here\'92s an example of using static_assert to ensure types have a certain size:\
\
\pard\pardeftab720\sl300\partightenfactor0

\f6\fs24 \cf5 \cb1 \

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalt \clcbpat8 \clwWidth344\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrs\brdrw60\brdrcf9 \clpadl0 \clpadr100 \gaph\cellx4320
\clvertalt \clcbpat8 \clwWidth16109\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadl0 \clpadr0 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\sl300\qc\partightenfactor0
\cf7 \cb6 1\cb1 \
\cb6 2\cb1 \
\cb6 3\cb1 \
\cb6 4\cb1 \
\cb6 5\cb1 \
\cb6 6\cb1 \
\cb6 7\cb1 \cell 
\pard\intbl\itap1\pardeftab720\sl300\partightenfactor0
\cf12 \cb6 static_assert\cf15 (\cf12 sizeof\cf15 (\cf12 long\cf15 )\cf13  == \cf16 8\cf15 ,\cf13  \cf18 "long must be 8 bytes"\cf15 );\cf5 \cb1 \
\cf12 \cb11 static_assert\cf15 (\cf12 sizeof\cf15 (\cf12 int\cf15 )\cf13  == \cf16 4\cf15 ,\cf13  \cf18 "int must be 4 bytes"\cf15 );\cf5 \
\cb6 \'a0\cb1 \
\cf12 \cb11 int\cf13  \cf14 main\cf15 ()\cf5 \
\cf15 \cb6 \{\cf5 \cb1 \
\cf13 \cb11 	\cf12 return\cf13  \cf16 0\cf15 ;\cf5 \
\cf15 \cb6 \}\cf13  \cf5 \cb1 \cell \lastrow\row
\pard\pardeftab720\sa260\partightenfactor0

\f3\fs26 \cf5 \cb6 \
On the author\'92s machine, when compiled, the compiler errors:\
\pard\pardeftab720\partightenfactor0

\f5 \cf5 1>c:\\consoleapplication1\\main.cpp(19): error C2338: long must be 8 bytes\
\pard\pardeftab720\sa260\partightenfactor0

\f3 \cf5 Because\'a0
\f5 static_assert
\f3 \'a0is evaluated by the compiler, the condition must be able to be evaluated at compile time. Also, unlike normal\'a0
\f5 assert
\f3 \'a0(which is evaluated at runtime),\'a0
\f5 static_assert
\f3 \'a0can be placed anywhere in the code file (even in global space).\
\
\pard\pardeftab720\sa260\partightenfactor0
\cf5 \
\pard\pardeftab720\sa360\partightenfactor0

\f7\b\fs36 \cf5 NDEBUG\
\pard\pardeftab720\sa260\partightenfactor0

\f3\b0\fs26 \cf5 The\'a0
\f5 assert
\f3 \'a0macro comes with a small performance cost that is incurred each time the assert condition is checked. Furthermore, asserts should (ideally) never be encountered in production code (because your code should already be thoroughly tested). Consequently, many developers prefer that asserts are only active in debug builds. C++ comes with a way to turn off asserts in production code. If the macro\'a0
\f5 NDEBUG
\f3 \'a0is defined, the assert macro gets disabled.\
\pard\pardeftab720\sa360\partightenfactor0

\f7\b\fs36 \cf5 Asserts vs error handling\
\pard\pardeftab720\sa260\partightenfactor0

\f3\b0\fs26 \cf5 Assertions and error handling are similar enough that their purposes can be confused, so let\'92s clarify:\
The goal of an assertion is to catch programming errors by documenting something that should never happen. If that thing does happen, then the programmer made an error somewhere, and that error can be identified and fixed. Assertions do not allow recovery from errors (after all, if something should never happen, there\'92s no need to recover from it), and the program will not produce a friendly error message.\
On the other hand, error handling is designed to gracefully handle cases that could happen (however rarely) in release configurations. These may or may not be recoverable, but one should always assume a user of the program may encounter them.\
}